/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ScrapbookPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_http = require("http");
var import_url = require("url");
var import_fs = require("fs");
var path = __toESM(require("path"));
var crypto = __toESM(require("crypto"));

// settingsTab.ts
var import_obsidian = require("obsidian");
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Overtime").setDesc(
      "How much should you be over the time for it to send you a notification?"
    ).addText(
      (text) => text.setPlaceholder("1.3").setValue(`${this.plugin.settings.overTime}`).onChange(async (value) => {
        this.plugin.settings.overTime = Number.parseFloat(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Generic File Name").setDesc(
      "If you have no question but you're adding a doc, which file should it be added to?"
    ).addText(
      (text) => text.setPlaceholder("scrapbook").setValue(`${this.plugin.settings.genericDocFilename}`).onChange(async (value) => {
        this.plugin.settings.genericDocFilename = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Working Time").setDesc("How long should each working session be? In minutes").addText(
      (text) => text.setPlaceholder("60").setValue(`${this.plugin.settings.workingTime}`).onChange(async (value) => {
        this.plugin.settings.workingTime = Number.parseInt(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Thinking Time").setDesc("How long should each thinking session be? In minutes").addText(
      (text) => text.setPlaceholder("8").setValue(`${this.plugin.settings.thinkingTime}`).onChange(async (value) => {
        this.plugin.settings.thinkingTime = Number.parseInt(value);
        await this.plugin.saveSettings();
      })
    );
  }
};
var settingsTab_default = SampleSettingTab;

// main.ts
var Importance = /* @__PURE__ */ ((Importance2) => {
  Importance2["High"] = "High";
  Importance2["Medium"] = "Medium";
  Importance2["Low"] = "Low";
  return Importance2;
})(Importance || {});
var IMPORTANCE_ORDER = {
  ["High" /* High */]: 3,
  ["Medium" /* Medium */]: 2,
  ["Low" /* Low */]: 1
};
var DEFAULT_SETTINGS = {
  timeSpent: 0,
  frontendUrl: "http://localhost:5000",
  apiPort: 8080,
  onBreak: false,
  overTime: 1.4,
  thinkingTime: 8,
  workingTime: 60,
  genericDocFilename: "scrapbook"
};
var ScrapbookPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.questionTimer = null;
    this.thinkingModeTimer = null;
    this.workingModeTimeout = null;
    this.questionsFilePath = "questions.md";
  }
  async onload() {
    await this.loadSettings();
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
    this.addSettingTab(new settingsTab_default(this.app, this));
    console.log("Scrapbook plugin loaded");
  }
  async onLayoutReady() {
    await this.startAPIServer();
    this.initializeTimers();
    console.log("Scrapbook plugin layout ready");
  }
  async onunload() {
    this.stopAllTimers();
    if (this.server) {
      this.server.close();
    }
    await this.saveCurrentState();
    console.log("Scrapbook plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async saveCurrentState() {
    if (await this.getCurrentQuestion()) {
      await this.saveSettings();
    }
  }
  // === QUESTION MANAGEMENT ===
  async getQuestionsFileContent() {
    const file = this.app.vault.getAbstractFileByPath(this.questionsFilePath);
    if (file instanceof import_obsidian2.TFile) {
      return this.app.vault.read(file);
    } else {
      console.log(
        "When finding questions, Questions file not found, creating new one..."
      );
      await this.createQuestionsFile();
      return this.getQuestionsFileContent();
    }
  }
  parseAdditionalFields(lines, title, completed) {
    let importance = "Low" /* Low */;
    let estimatedTime = void 0;
    let startTime = void 0;
    let timeSpent = 0;
    lines.flatMap(
      (line) => line.split(", ").map((line2) => line2.trim().replace(")", "").replace("(", ""))
    ).forEach((fieldLine) => {
      if (fieldLine.includes("Importance:")) {
        const parsedImportance = fieldLine.split("Importance:")[1].trim();
        if (parsedImportance in Importance) {
          importance = parsedImportance;
        }
      } else if (fieldLine.includes("Estimated:")) {
        const timeStr = fieldLine.split("Estimated:")[1].trim();
        estimatedTime = this.parseTimeString(timeStr);
      } else if (fieldLine.includes("Started:")) {
        const timeStr = fieldLine.split("Started:")[1].trim();
        startTime = new Date(timeStr);
      } else if (fieldLine.includes("Time Spent:")) {
        const timeStr = fieldLine.split("Time Spent:")[1].trim();
        timeSpent = this.parseTimeString(timeStr);
      }
    });
    return {
      title,
      importance,
      estimatedTime,
      startTime,
      timeSpent,
      completed
    };
  }
  async getCurrentQuestion() {
    const content = await this.getQuestionsFileContent();
    const sections = content.split("## ");
    const activeSection = sections.find(
      (section) => section.startsWith("Active")
    );
    if (!activeSection)
      return null;
    const lines = activeSection.split("\n").slice(1).map((line) => line.trim());
    for (const line of lines) {
      if (line.startsWith("- [")) {
        const completed = line.startsWith("- [x]");
        const titleMatch = line.match(/\*\*(.*?)\*\*/);
        if (!titleMatch)
          continue;
        const title = titleMatch[1];
        return this.parseAdditionalFields(lines, title, completed);
      }
    }
    return null;
  }
  async getSectionQuestions(section) {
    const questions = [];
    const content = await this.getQuestionsFileContent();
    const sections = content.split("## ");
    const targetSection = sections.find((sec) => sec.startsWith(section));
    if (!targetSection) {
      console.log(`Section "${section}" not found in questions file.`);
      return questions;
    }
    const lines = targetSection.split("\n").slice(1).map((line) => line.trim());
    for (const line of lines) {
      if (line.startsWith("- [")) {
        const completed = line.startsWith("- [x]");
        const titleMatch = line.match(/\*\*(.*?)\*\*/);
        if (!titleMatch)
          continue;
        questions.push(
          this.parseAdditionalFields([line], titleMatch[1], completed)
        );
      }
    }
    return questions;
  }
  async getPendingQuestions() {
    return await this.getSectionQuestions("Pending");
  }
  async getCompletedQuestions() {
    return await this.getSectionQuestions("Completed");
  }
  async getAllQuestions() {
    const questions = await this.getPendingQuestions();
    questions.push(...await this.getCompletedQuestions());
    const activeQuestion = await this.getCurrentQuestion();
    if (activeQuestion) {
      questions.push(activeQuestion);
    }
    return questions;
  }
  parseTimeString(timeStr) {
    let minutes = 0;
    const hourMatch = timeStr.match(/(\d+)h/);
    const minuteMatch = timeStr.match(/(\d+)m/);
    if (hourMatch)
      minutes += parseInt(hourMatch[1]) * 60;
    if (minuteMatch)
      minutes += parseInt(minuteMatch[1]);
    return minutes;
  }
  formatTimeString(minutes) {
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    if (hours > 0 && remainingMinutes > 0) {
      return `${hours}h ${remainingMinutes}m`;
    } else if (hours > 0) {
      return `${hours}h`;
    } else {
      return `${remainingMinutes}m`;
    }
  }
  async addQuestion(questionData, moveToIt) {
    const question = {
      title: questionData.title,
      importance: questionData.importance || "Low" /* Low */,
      estimatedTime: questionData.estimatedTime,
      timeSpent: 0,
      completed: false
    };
    let activeQuestion;
    let restOfQuestions = [];
    const currentQuestion = await this.getCurrentQuestion();
    if (currentQuestion)
      currentQuestion.timeSpent = this.settings.timeSpent;
    if (!moveToIt) {
      activeQuestion = currentQuestion || void 0;
      restOfQuestions.push(question);
    } else {
      activeQuestion = question;
      if (currentQuestion) {
        restOfQuestions.push(currentQuestion);
      }
    }
    restOfQuestions.push(...await this.getPendingQuestions());
    restOfQuestions.push(...await this.getCompletedQuestions());
    await this.updateQuestionsFile(restOfQuestions, activeQuestion);
  }
  async completeCurrentQuestion() {
    const current = await this.getCurrentQuestion();
    if (!current) {
      this.notifyNoQuestion();
      return;
    }
    current.timeSpent = this.settings.timeSpent;
    current.completed = true;
    this.settings.timeSpent = 0;
    await this.saveSettings();
    const pendingQuestions = await this.getPendingQuestions();
    let activeQuestion = void 0;
    if (pendingQuestions.length > 0) {
      activeQuestion = pendingQuestions.shift();
    }
    pendingQuestions.push(current);
    const completedQuestions = await this.getCompletedQuestions();
    pendingQuestions.push(...completedQuestions);
    await this.updateQuestionsFile(pendingQuestions, activeQuestion);
    this.stopQuestionTimer();
    new import_obsidian2.Notice(`Question completed: ${current.title}`);
  }
  async onChangeQuestion(question) {
    this.settings.timeSpent = question.timeSpent;
    await this.saveSettings();
    if (!question.startTime) {
      question.startTime = new Date();
    }
    this.startQuestionTimer(true);
    this.notifyNewQuestion(question.title);
  }
  async notifyNoQuestion() {
    await this.notifyNewQuestion("No active question");
  }
  async notifyNewQuestion(questionTitle) {
    await this.notifyFrontend("/current-question", {
      question: {
        title: questionTitle
      }
    });
    new import_obsidian2.Notice(`Started: ${questionTitle}`);
  }
  // === TIMER MANAGEMENT ===
  async initializeTimers() {
    if (await this.getCurrentQuestion() && !this.settings.onBreak) {
      this.startQuestionTimer(false);
      this.startThinkingModeTimer();
    }
  }
  async startQuestionTimer(fromZero) {
    this.stopQuestionTimer();
    if (fromZero) {
      this.settings.timeSpent = 0;
      await this.saveSettings();
    }
    this.questionTimer = setInterval(() => {
      if (!this.settings.onBreak) {
        this.settings.timeSpent += 1;
        this.checkOvertime(this.settings.timeSpent);
        this.saveSettings();
      }
    }, 6e4);
  }
  stopQuestionTimer() {
    if (this.questionTimer) {
      clearInterval(this.questionTimer);
      this.questionTimer = null;
    }
  }
  stopThinkingTimer() {
    if (this.thinkingModeTimer) {
      clearInterval(this.thinkingModeTimer);
      this.questionTimer = null;
    }
    if (this.workingModeTimeout) {
      clearTimeout(this.workingModeTimeout);
      this.workingModeTimeout = null;
    }
  }
  startThinkingModeTimer() {
    this.stopThinkingTimer();
    this.thinkingModeTimer = setInterval(() => {
      if (!this.settings.onBreak)
        this.startThinkingMode();
    }, this.settings.workingTime * 60 * 1e3);
  }
  async startThinkingMode() {
    this.settings.onBreak = true;
    await this.saveCurrentState();
    await this.notifyFrontend("/current-question", {
      question: {
        title: "Thinking mode!",
        importance: "High" /* High */,
        estimatedTime: this.settings.thinkingTime
      }
    });
    new import_obsidian2.Notice(
      `Thinking mode! Take ${this.settings.thinkingTime} minutes to reflect.`
    );
    this.workingModeTimeout = setTimeout(async () => {
      new import_obsidian2.Notice("Thinking mode complete. Back to work!");
      const current = await this.getCurrentQuestion();
      if (current) {
        this.settings.onBreak = false;
        await this.saveCurrentState();
        await this.notifyFrontend("/current-question", {
          question: {
            title: current.title,
            importance: current.importance,
            estimatedTime: current.estimatedTime
          }
        });
      }
    }, this.settings.thinkingTime * 60 * 1e3);
  }
  async checkOvertime(timeSpent) {
    const current = await this.getCurrentQuestion();
    if (!current || !current.estimatedTime)
      return;
    const threshold = current.estimatedTime * this.settings.overTime;
    if (timeSpent > threshold) {
      this.notifyFrontend("/overtime-alert", {
        question: current.title,
        estimatedTime: current.estimatedTime,
        actualTime: timeSpent,
        overBy: timeSpent - current.estimatedTime
      });
    }
  }
  stopAllTimers() {
    this.stopQuestionTimer();
    this.stopThinkingTimer();
  }
  // === FILE OPERATIONS ===
  async createQuestionsFile() {
    const content = `# Questions Queue
## Active
- [ ] **Current Question Title**
- Importance: High
- Estimated: 2h
- Started: 2025-06-19 10:30
- Time Spent: 1h 23m
## Pending
- [ ] **Next Question** (Importance: Medium, Estimated: 1h)
- [ ] **Another Question** (Importance: Low, Estimated: 30m)
## Completed
- [x] **Previous Question** (Time Spent: 45m/1h)
`;
    await this.app.vault.create(this.questionsFilePath, content);
  }
  async updateQuestionsFile(questions, active) {
    const oldActive = await this.getCurrentQuestion();
    const content = this.generateQuestionsMarkdown(questions, active);
    const file = this.app.vault.getAbstractFileByPath(this.questionsFilePath);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(file, content);
    } else {
      await this.app.vault.create(this.questionsFilePath, content);
    }
    const updatedActive = await this.getCurrentQuestion();
    if (updatedActive) {
      if (updatedActive.title !== (oldActive == null ? void 0 : oldActive.title))
        this.onChangeQuestion(updatedActive);
    } else {
      this.notifyNoQuestion();
    }
  }
  generateQuestionsMarkdown(questions, active) {
    const notCompleted = questions.filter((q) => !q.completed);
    const completed = questions.filter((q) => q.completed);
    if (notCompleted) {
      notCompleted.sort(
        (a, b) => IMPORTANCE_ORDER[b.importance] - IMPORTANCE_ORDER[a.importance]
      );
      if (!active) {
        active = notCompleted.shift();
      }
    }
    let content = "# Questions Queue\n\n## Active\n";
    if (active) {
      content += `- [ ] **${active.title}**
`;
      content += `  - Importance: ${active.importance}
`;
      if (active.estimatedTime)
        content += `  - Estimated: ${this.formatTimeString(
          active.estimatedTime
        )}
`;
      if (active.startTime)
        content += `  - Started: ${active.startTime.toISOString().slice(0, 16).replace("T", " ")}
`;
      content += `  - Time Spent: ${this.formatTimeString(
        active.timeSpent
      )}

`;
    }
    content += "## Pending\n";
    notCompleted.forEach((q) => {
      content += `- [ ] **${q.title}**`;
      const details = [];
      details.push(`Importance: ${q.importance}`);
      if (q.estimatedTime)
        details.push(`Estimated: ${this.formatTimeString(q.estimatedTime)}`);
      if (q.timeSpent > 0)
        details.push(`Time Spent: ${this.formatTimeString(q.timeSpent)}`);
      if (details.length > 0)
        content += ` (${details.join(", ")})`;
      content += "\n";
    });
    content += "\n## Completed\n";
    completed.forEach((q) => {
      content += `- [x] **${q.title}**`;
      const details = [];
      if (q.timeSpent > 0)
        details.push(`Time Spent: ${this.formatTimeString(q.timeSpent)}`);
      if (q.estimatedTime)
        details.push(`Estimated: ${this.formatTimeString(q.estimatedTime)}`);
      if (details.length > 0)
        content += ` (${details.join(", ")})`;
      content += "\n";
    });
    return content;
  }
  getVaultFiles() {
    const files = this.app.vault.getMarkdownFiles();
    return files.map((file) => file.path);
  }
  async appendToFile(targetFile, content) {
    const file = this.app.vault.getAbstractFileByPath(targetFile);
    if (file instanceof import_obsidian2.TFile) {
      const existingContent = await this.app.vault.read(file);
      const newContent = existingContent + "\n\n" + content;
      await this.app.vault.modify(file, newContent);
    } else {
      await this.app.vault.create(targetFile, content);
    }
  }
  async saveImage(imageData, filename) {
    const attachmentsFolder = "attachments";
    if (!this.app.vault.getAbstractFileByPath(attachmentsFolder)) {
      await this.app.vault.createFolder(attachmentsFolder);
    }
    const binaryString = atob(imageData);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    const imagePath = `${attachmentsFolder}/${filename}`;
    await this.app.vault.createBinary(imagePath, bytes.buffer);
    return imagePath;
  }
  // === API SERVER ===
  async startAPIServer() {
    console.log("Starting Scrapbook API server...");
    this.server = (0, import_http.createServer)(
      async (req, res) => {
        console.log(`Received request: ${req.method} ${req.url}`);
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        res.setHeader("Access-Control-Allow-Headers", "Content-Type");
        if (req.method === "OPTIONS") {
          res.writeHead(200);
          res.end();
          return;
        }
        const parsedUrl = (0, import_url.parse)(req.url || "", true);
        const path2 = parsedUrl.pathname;
        this.handleAPIRequest(req, res, path2);
      }
    );
    this.server.listen(this.settings.apiPort, () => {
      console.log(
        `Scrapbook API server running on port ${this.settings.apiPort}`
      );
    });
  }
  async handleAPIRequest(req, res, path2) {
    try {
      if (req.method === "POST") {
        let body = "";
        req.on("data", (chunk) => body += chunk);
        req.on("end", async () => {
          try {
            const data = JSON.parse(body);
            await this.handlePOSTRequest(path2, data, res);
          } catch (error) {
            this.sendError(res, 400, "Invalid JSON");
          }
        });
      } else if (req.method === "GET") {
        await this.handleGETRequest(path2, null, res);
      } else {
        this.sendError(res, 405, "Method not allowed");
      }
    } catch (error) {
      this.sendError(res, 500, "Internal server error");
    }
  }
  async handlePOSTRequest(path2, data, res) {
    switch (path2) {
      case "/api/question/add":
        await this.addQuestion(data, false);
        this.sendSuccess(res, { message: "Question added" });
        break;
      case "/api/question/add-and-move":
        await this.addQuestion(data, true);
        this.sendSuccess(res, { message: "Question added and moved to" });
        break;
      case "/api/docs/add":
        await this.handleDocumentationRequest(data);
        this.sendSuccess(res, { message: "Documentation added" });
        break;
      default:
        this.sendError(res, 404, "POST Endpoint not found");
    }
  }
  async handleGETRequest(path2, data, res) {
    var _a;
    switch (path2) {
      case "/api/question/complete":
        await this.completeCurrentQuestion();
        this.sendSuccess(res, { message: "Question completed" });
        break;
      case "/api/break/start":
        this.settings.onBreak = true;
        await this.saveSettings();
        this.stopAllTimers();
        await this.notifyFrontend("/current-question", {
          question: {
            title: "on a break!",
            importance: "High" /* High */
          }
        });
        this.sendSuccess(res, { message: "Break started" });
        break;
      case "/api/break/end":
        this.settings.onBreak = false;
        await this.saveSettings();
        this.startQuestionTimer(false);
        this.startThinkingModeTimer();
        const currentQuestion = (_a = await this.getCurrentQuestion()) == null ? void 0 : _a.title;
        if (currentQuestion) {
          await this.notifyFrontend("/current-question", {
            question: {
              title: currentQuestion
            }
          });
        } else
          this.notifyNoQuestion();
        this.sendSuccess(res, { message: "Break ended" });
        break;
      case "/api/files":
        const files = this.getVaultFiles();
        this.sendSuccess(res, { files });
        break;
      case "/api/question/get":
        const question = this.getCurrentQuestion();
        this.sendSuccess(res, { question });
        break;
      default:
        this.sendError(res, 404, "GET Endpoint not found");
    }
  }
  async moveFileToAttachments(externalFilePath) {
    try {
      const fileExists = await this.fileExists(externalFilePath);
      if (!fileExists) {
        new import_obsidian2.Notice(`File not found: ${externalFilePath}`);
        return null;
      }
      const fileName = path.basename(externalFilePath);
      const fileExt = path.extname(fileName);
      const attachmentsPath = "attachments";
      if (!await this.app.vault.adapter.exists(attachmentsPath)) {
        await this.app.vault.createFolder(attachmentsPath);
      }
      const fileBuffer = await import_fs.promises.readFile(externalFilePath);
      const md5FileName = this.generateMD5FileName(fileBuffer, fileExt);
      const targetPath = `${attachmentsPath}/${md5FileName}`;
      let createdFile;
      if (await this.app.vault.adapter.exists(targetPath)) {
        createdFile = this.app.vault.getAbstractFileByPath(targetPath);
        new import_obsidian2.Notice(`File already exists with same content: ${targetPath}`);
      } else {
        const arrayBuffer = fileBuffer.buffer.slice(
          fileBuffer.byteOffset,
          fileBuffer.byteOffset + fileBuffer.byteLength
        );
        createdFile = await this.app.vault.createBinary(
          targetPath,
          arrayBuffer
        );
        new import_obsidian2.Notice(`File moved to: ${targetPath}`);
      }
      return createdFile;
    } catch (error) {
      console.error("Error moving file:", error);
      new import_obsidian2.Notice(`Error moving file: ${error.message}`);
      return null;
    }
  }
  generateMD5FileName(fileBuffer, extension) {
    const hash = crypto.createHash("md5");
    hash.update(fileBuffer);
    const md5Hash = hash.digest("hex");
    return `${md5Hash}${extension}`;
  }
  async fileExists(filePath) {
    try {
      await import_fs.promises.access(filePath);
      return true;
    } catch (e) {
      return false;
    }
  }
  async handleDocumentationRequest(docReq) {
    var _a;
    let content = docReq.text;
    let targetFile = docReq.targetFile;
    if (docReq.imageFilename) {
      const imagePath = await this.moveFileToAttachments(docReq.imageFilename);
      content = `![[${imagePath == null ? void 0 : imagePath.path}]]

${content}`;
    }
    if (!targetFile) {
      targetFile = ((_a = await this.getCurrentQuestion()) == null ? void 0 : _a.title) || this.settings.genericDocFilename;
      targetFile += ".md";
    }
    await this.appendToFile(targetFile, content);
    new import_obsidian2.Notice(`Added to ${targetFile}`);
  }
  sendSuccess(res, data) {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ success: true, ...data }));
  }
  sendError(res, code, message) {
    console.error(`Error ${code}: ${message}`);
    res.writeHead(code, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ success: false, error: message }));
  }
  async notifyFrontend(endpoint, data) {
    try {
      await (0, import_obsidian2.requestUrl)({
        url: `${this.settings.frontendUrl}${endpoint}`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data)
      });
    } catch (error) {
      console.error(
        `Failed to notify frontent. endpoint: ${endpoint}, data: ${data}, and error: ${error}`
      );
    }
  }
};
